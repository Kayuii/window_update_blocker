use std::fs::File;
use std::time::Duration;

use is_terminal::IsTerminal;
use own_logger::{
    gol::{self, LoggingOptions, TracingOptions},
    info,
};
use tracing::level_filters::LevelFilter;
use tracing_subscriber::EnvFilter;

pub const DEFAULT_LOG_FILTER: &[&'static str] = &[
    "own_logger",
    "windows_update_blocker",
    "hyper=info",
    "mio=info",
    "reqwest=warn",
];

/// Control the output generated by the CLI.
#[derive(Debug, Default, Clone, PartialEq, clap::Parser)]
pub struct Logging {
    /// Generate verbose output (repeat for more verbosity)
    #[clap(short, long, action = clap::ArgAction::Count, global = true, conflicts_with = "quiet")]
    pub verbose: u8,
    /// Do not print progress messages.
    #[clap(short, long, global = true, conflicts_with = "verbose")]
    pub quiet: bool,
    /// When to display colored output.
    #[clap(long, default_value_t = clap::ColorChoice::Auto, global = true)]
    pub color: clap::ColorChoice,
}

impl Logging {
    /// Has the `--verbose` flag been set?
    pub fn is_verbose(&self) -> bool {
        self.verbose > 0
    }

    pub fn initialize_logging(&self) {
        let mut path = std::env::current_exe()
            .unwrap()
            .parent()
            .unwrap()
            .to_path_buf();

        path.push("logs");
        let dir = path.to_str().unwrap().to_owned();

        let level = self.log_filter().to_string();

        let opts = LoggingOptions {
            dir: Some(dir.clone()),
            level: Some(level),
            ..Default::default()
        };
        gol::init_logging("windows_update_blocker", &opts);
    }

    fn log_filter(&self) -> EnvFilter {
        let default_filters = [
            LevelFilter::OFF,
            LevelFilter::WARN,
            LevelFilter::INFO,
            LevelFilter::DEBUG,
        ];

        // First, we set up the default log level.
        let default_level = default_filters
            .get(self.verbose as usize)
            .copied()
            .unwrap_or(LevelFilter::TRACE);
        let mut filter = EnvFilter::builder()
            .with_default_directive(default_level.into())
            .from_env_lossy();

        // Next we add level-specific directives, where verbosity=0 means don't
        // override anything. Note that these are shifted one level up so we'll
        // get something like RUST_LOG="warn,agnet_server=info"
        let specific_filters = [LevelFilter::WARN, LevelFilter::INFO, LevelFilter::DEBUG];
        if self.verbose > 0 {
            let level = specific_filters
                .get(self.verbose as usize)
                .copied()
                .unwrap_or(LevelFilter::TRACE);

            for target in DEFAULT_LOG_FILTER {
                match target.matches("=").next() {
                    Some(_) => {
                        let directive = format!("{target}").parse().unwrap();
                        filter = filter.add_directive(directive);
                    }
                    None => {
                        let directive = format!("{target}={level}").parse().unwrap();
                        filter = filter.add_directive(directive);
                    }
                }
            }
        }

        filter
    }

    fn should_emit_colors(&self) -> bool {
        match self.color {
            clap::ColorChoice::Auto => std::io::stderr().is_terminal(),
            clap::ColorChoice::Always => true,
            clap::ColorChoice::Never => false,
        }
    }
}
